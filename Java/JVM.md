# JVM이란?

OS에 종속받지 않고 CPU가 JAVA를 인식, 실행할 수 있게 하는 가상 컴퓨터이다.

그렇기 때문에,JAVA 언어는 JVM에 의해 운영체제 독립적이라는 장점을 가질 수 있게 된다.

Java 소스코드는 CPU가 인식하지 못하므로 기계어로 컴파일을 해줘야 한다.

하지만 Java는 이 JVM이라는 가상 머신을 거쳐서 OS에 도달하기 때문에 OS가 인식할 수 있는 기계어로 바로 컴파일 되는게 아니라 JVM이 인식할 수 있는 Java Bytecode로 변환된다.

> 자바 컴파일러는 JDK에 속해있다.

변환된 bytecode는 기계어가 아니기 때문에 OS가 해석할 수 없기 때문에 JVM을 통해 bytecode를 OS가 해석할 수 있는 기계어로 변환한다.

즉, 이렇게 JAVA 언어로 작성한 소스파일은 바로 운영체제로 가는 것이 아닌, JVM을 거쳐서 운영체제와 상호작용을 하는데 이 때문에 개발자가 소스코드를 작성하는 것에 있어서 운영체제로부터 독립적일 수 있게 된다.

## JVM의 구성

- 클래스 로더
- 실행 엔진
    - 인터프피터
    - JIT 컴파일러
    - 가비지 콜렉터
- 런타임 데이터 영역

### 클래스 로더

JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.
런 타임시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM위에 탑재한다.
즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 역할을 한다.
> 클래스 로딩이란?
>
> 런타임 데이터 영역에 클래스를 저장하는 것

> 클래스 링크란?
>
> 로딩하는 과정을 포함해 로딩된 클래스 파일에 대해 검증, 준비, 해석의 세 단계를 거치는 것
> 
> 검증: 읽어 들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사

### 실행 엔진

클래스를 실행시키는 역할이다.

클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키면, 실행 엔진에 의해 실행할 수 있다.

> 자바 바이트 코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다.
>
>위에서 설명했 듯이 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다.

**인터프리터**

실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다. 하지만 한 줄 씩 수행하기 때문에 느리다는 단점이 있다.

**JIT**

인터프리터 방식으로 시랳ㅇ하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경하고, 이휴에는 해당 더 이상 인터프리팅 하지 않고 기계어로 직접 실행하는 방식이다.
JIT 컴파일러가 컴파일하는 과정은 바이트 코드를 인터프리팅하는 것보다 훨씬 오래걸리므로 한 번만 실행되는 코드라면 컴파일 하지 않고 인터프리팅하는 것이 유리하다.

**가비지 컬렉터**

더 이상 사용되느 않는 인스턴스를 찾아 메모리에서 삭제한다.